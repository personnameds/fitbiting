<!DOCTYPE html>
<html>
	<head>
		<title>FitMap</title>
    	<meta name="viewport" content="initial-scale=1.0">
    	<meta charset="utf-8">
		<style>
			/* Always set the map height explicitly to define the size of the div
			* element that contains the map. */
			#map {
				float: right;
				height: 100%;
				width: 100%
			}
			/* Optional: Makes the sample page fill the window. */
			html, body {
				height: 100%;
				margin: 0;
				padding: 10px;
			}
		</style>
	</head>
	<body>
  		<a href="{% url 'homepage-index' %}">Homepage</a>
		<a href="{% url 'admin:index' %}">Admin</a>
		<a href="{% url 'fitdata-index' %}">Fitbit Data</a>
 		
  		<h2>{{fitroute.title}}</h2>
		<body onload="displayRoute()">

  		<div id="map"></div>

 
		<script>
			//Display the previous route data
			function displayRoute() {
			
				var map = new google.maps.Map(document.getElementById('map'));

				var marker; 
				
				var cs='#FF0000'
					
				//Decode the saved and encoded route data
				{% for mappedrte in mappedrte_all %}
				
					var decodedPath=google.maps.geometry.encoding.decodePath("{{mappedrte.maprtedata}}");
					
					var runPath = new google.maps.Polyline({
						path: decodedPath,
						strokeColor: cs,
						strokeWeight:4
						});

					marker = new google.maps.Marker({
								position: decodedPath[decodedPath.length-1],
								map: map,
								});
								
					marker = new google.maps.Marker({
								position: decodedPath[0],
								map: map,
								});
					
					{% if forloop.first %}
						var first_position=decodedPath[0];
					{% endif %}
									
					//Sets the path to the map to be displayed
					runPath.setMap(map);
					
					cs="#880088";
					
				{% endfor %} 
				
				var bounds=new google.maps.LatLngBounds();
				bounds.extend(first_position);
				bounds.extend(decodedPath[decodedPath.length-1]);
				map.fitBounds(bounds);	
				
				{% if fitdata_all %} //Checks if new FitData
					//Update the map with new data
					var directionsService = new google.maps.DirectionsService();
					var start = {lat: decodedPath[decodedPath.length-1].lat(), lng: decodedPath[decodedPath.length-1].lng()};
					var end = {lat: {{fitroute.end_lat}}, lng: {{fitroute.end_long}}};

// 					var waypts=[
// 						{% for waypoint in waypoints %}
// 							{location: new google.maps.LatLng({{waypoint.lat}},{{waypoint.long}}),stopover: true},
// 						{% endfor %}
//								]; //waypts

					var request = {
							   origin: start,
							   destination: end,
//						   waypoints: waypts,
							   travelMode: 'WALKING'
							  }; // Request	

					directionsService.route(request, function(result, status) {
						if (status == 'OK') {
							
							var a=0;
							var b=0;
							var c=0;
							var dist=0;
							var olddist=0;
							var latlongs=[];
							var z=0;
							var strokecolor=["#0082c8","#3cb44b","#911eb4","#000080","#46f0f0#","#f58231","#f032e6","#e6beff"];
							var col=0;
							var order={{order}};
						
							{% for fitdata in fitdata_all %}
						
								//Convert route into polylines
								var distance={{fitdata.distance}}*1000;
								var legs=result.routes[0].legs; //legs are point to point
								legs:
								for (i = a; i < legs.length; i++) {
									var steps = legs[i].steps; //steps are steps in each leg
									steps:
									for (j=b; j < steps.length; j++) {
										var nextSegment = steps[j].path; //lat and long for each step
										segments:
										for (k=c; k < nextSegment.length; k++) {
											latlongs[z]=nextSegment[k];  //latlongs holds array of lat and long for each step
											if (z>0) {
											olddist=dist;
											dist+= google.maps.geometry.spherical.computeDistanceBetween(latlongs[z],latlongs[z-1]);
											}
											if (dist >= distance) {
												break legs;
											}
											z++;

										} //for k
									c=0;
									} // for j
								b=0;
								} // for i

								//Find the exact point where the distance is met
								//Finds the spot along the last polyline
								var percentDist=(distance-olddist)/(dist-olddist);
								var stopSpot = google.maps.geometry.spherical.interpolate(latlongs[z-1],latlongs[z],percentDist);
								latlongs[z]=stopSpot;  

								marker = new google.maps.Marker({
									position: latlongs[0],
									map: map
									});

								marker = new google.maps.Marker({
									position: latlongs[z],
									map: map
									});

								marker = new google.maps.Marker({
									position: end,
									map: map
									});

								var runPath= new google.maps.Polyline({
									path: latlongs,
									strokeColor: strokecolor[col],
									strokeWeight:4
								});
			
								col++;
								if (col > strokecolor.length) {
									col=0;
									}
					
								var encodedPath = google.maps.geometry.encoding.encodePath(runPath.getPath());
								encodedPath=encodedPath.replace(/\\/g, "\\\\");
								var data =  {'encodedPath':encodedPath,
											 'fitbiter':'{{fitdata.fitbiter}}',
											 'fitroute':'{{fitroute.name}}',
											 'strokecolor':strokecolor[col],
											 'order':order,
											 'num_complete_waypt':i
											 };
				
								//Django is returning a success variable but not sure how to see it
								//Reusing the createroute_savemapped route
								$.getJSON("{% url 'createroute_savemappedroute' %}", data);					

						
								{% if forloop.first %}
									var first_marker=latlongs[0];
								{% endif %}
							
								//Display the route on the map
								runPath.setMap(map);
							
								a=i;
								b=j;
								c=k;
								z=0; 
								latlongs=[];
								latlongs[z]=stopSpot;
								z=1;
								dist=dist-distance;	
								order=order+1;
							
							{% endfor %}
						
							//Make the map the size of the latest route
							var last_marker=stopSpot;
							var bounds=new google.maps.LatLngBounds();
							bounds.extend(last_marker);
							bounds.extend(first_marker);
							map.fitBounds(bounds);
					
						} else {
							console.log('Not OK');
							console.log(status);
							}
				
					}); // Close Directions Service Route			
				{% endif %} //Checks if new FitData
			} //End of Display Route Function
		</script>
    	<script src="https://maps.googleapis.com/maps/api/js?key={{API_KEY}}&libraries=geometry&places&callback=displayRoute" async defer></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	
  	 </body>	
</html>