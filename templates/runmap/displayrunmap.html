{% extends "base.html" %}

{% block head_content %}
<style>
	#map {
		height: 500px;
		width: 100%;
	}
	
	#SideBarChart {
		width: 100%;
	}

	#PieChart {
		width: 100%;
	}
	
	html, body {
		height: 100%;
	}
		
</style>

<!-- Google Charts -->
<!-- Side Bar Chart -->
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script type="text/javascript">
	google.charts.load('current', {packages: ['corechart']});
	google.charts.setOnLoadCallback(drawChart);

	function drawChart() {
		var stacked_data = google.visualization.arrayToDataTable([
			['Date',
			{% for r in rterunners %}
				'{{r.runner.user.username}}',
			{% endfor %}
			],
			{% for data_date in data_table %}
				[
				{% for d in data_date %}
					{% if forloop.first %}
						'{{d}}',
					{% else %}
						{{d}},
					{% endif %}
				{% endfor %}
				],			
			{% endfor %}
		]);

 		var pie_data = google.visualization.arrayToDataTable([
 			['Runners','Distance (km)'],
 			{% for p in pie_data_table %}
 				['{{p.0}}',{{p.1}}],
 			{% endfor %}
 			['Distance Left',total_distance],
 		]);

		var stacked_options = {
			isStacked: 'percent',
			height: 300,
			legend: {position: 'top', maxLines: 3},
			hAxis: {
			minValue: 0,
			ticks: [0, .25, .5, .75, 1]
			},
			series:{
				{% for r in rterunners %}
					{{forloop.counter0}}:{color:'{{r.colour}}'},
				{% endfor %}
				},
		};
		
		var pie_options = {
			colors:
				[
				{% for r in rterunners %}
					'{{r.colour}}',
				{% endfor %}
				'#808080',
				],
		};

	  // Instantiate and draw the chart.
	  var stacked_chart = new google.visualization.BarChart(document.getElementById('SideBarChart'));
	  stacked_chart.draw(stacked_data, stacked_options);
	  var pie_chart = new google.visualization.PieChart(document.getElementById('PieChart'));
	  pie_chart.draw(pie_data, pie_options);

	}
</script>
<!-- Map Display-->
<script>		
	var total_distance;
	
	function initMap() {
		installEpoly();
  		displayRoute();
	}
	
	function displayRoute() {
	
        var map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 43.66, lng: -79.45},
        });
		var directionsService = new google.maps.DirectionsService();
		var start = {lat: {{route.start_lat}}, lng: {{route.start_long}}};
		var end = {lat: {{route.end_lat}}, lng: {{route.end_long}}};
		var request = {
				   origin: start,
				   destination: end,
				   travelMode: 'WALKING',
				   avoidFerries: false,
				  }; // Request		
	
		directionsService.route(request, function(response, status) {
			if (status == 'OK') {
				var route=response.routes[0].legs[0]
				total_distance=route.distance.value/1000;
				
				var i=0
				var last_i=0;
				var runPath=[];
				var stopPath_dist;

				{% for rundate, rterunner, rundata in rundata_list %}
					//Each fitbiter, each date how far they ran
					var dist_ran={{rundata.distance}}*1000;
console.log('{{runner}}');
					//Check if they have run today
					if (dist_ran > 0) {
						//IF stop PathTo has value
						if (stopPath_dist) {
							//Get points for stop spot up to next step
							if (stopPath_dist < dist_ran) {
								//If the PathTo distance is less than the dist_ran 	
								//Add the distance left to the sum_dist_steps
								//Add the PathFrom to runPath				
								sum_dist_steps = stopPath_dist;
								along_stopPathFrom=false;
								for (l=0; l < stopPath.pathFrom.length; l++) {
									runPath.push(stopPath.pathFrom[l]);
								} //stopPathTo loop	
console.log('PathFrom added - stopPath_dist:'+l);
							} else if (stopPath_dist >= dist_ran) {
								//Needs to stop somewhere along stopPathFrom 
								sum_dist_steps = stopPath_dist;
								along_stopPathFrom=true;
							}						
						} else {
							// first loop no stopPathTo_dist
							var sum_dist_steps = 0;
							var along_stopPathFrom=false;
						}				
console.log('Dist_Ran:'+dist_ran+' stopPath:'+stopPath_dist+' along_stopPath:'+along_stopPathFrom);
						while (sum_dist_steps < dist_ran) {
							sum_dist_steps += route.steps[i].distance.value;
console.log('i:'+i+' sum_dist:'+sum_dist_steps+' dist_ran:'+dist_ran);
							i++;
						} // while dist_steps
					
						//Create Array of LatLngs from Steps with less distance than distance ran
						// -2 because -1 is for the i++ other -1 is because last step went to far 
						//then + 1 because loop j starts at 0 or last_i which is equivalent to zero
						//Loop through steps
console.log('Out - i:'+i+' sum_dist:'+sum_dist_steps+' dist_ran:'+dist_ran+' stepLength:'+route.steps[i-1].distance.value);					
						for (j=last_i; j < i - 1; j++) {
console.log('j:'+j);
							stepPath=route.steps[j].path
							//Loop through points
							for (k=0; k < stepPath.length; k++) {
								runPath.push(stepPath[k]);
							}
						} 
console.log(along_stopPathFrom);
						if (along_stopPathFrom==false) { 
							//Regular stopPoint finding
							//Find the exact stop point and the path up to that point
							var stepPoly = new google.maps.Polyline({
								path: route.steps[i-1].path,
							});
				
							var distanceThisStep = route.steps[i-1].distance.value;
							var stopPath = stepPoly.GetPointAtDistance(distanceThisStep - (sum_dist_steps - dist_ran));
console.log('stopPath - i:'+i+' distanceThisStep:'+distanceThisStep);
							if (stopPath == null) {
								console.log("stepPoly.GetPointAtDistance(" + distanceThisStep + ") returns null");
								return;
							} //if stopPath == Null
							//Get points for last step up to stop point
							for (j=0; j < stopPath.pathTo.length; j++) {
								runPath.push(stopPath.pathTo[j]);
							} //stopPath loop	
						
							stopPath_dist = sum_dist_steps - dist_ran;			
					
						} else {
							//Short route finding Stop point on the PathFrom
							var stepPoly = new google.maps.Polyline({
								path: stopPath.pathFrom,
							});
console.log('stepPoly - dist_ran:'+dist_ran);
							var stopPath = stepPoly.GetPointAtDistance(dist_ran);
							if (stopPath == null) {
								console.log("stepPoly.GetPointAtDistance(" + dist_ran + ") returns null");
								return;
							} //if stopPath == Null	

							for (j=0; j < stopPath.pathTo.length; j++) {
								runPath.push(stopPath.pathTo[j]);
							} //stopPath loop	
						
							stopPath_dist = sum_dist_steps - dist_ran;
						} //if along_stopPathTo
console.log('End '+stopPath_dist);				
						//Add the stop point
						runPath.push(stopPath.point);
console.log('Here:'+'{{rterunner}}')
						var polyline_runPath = new google.maps.Polyline({
							path: runPath,
							strokeColor: '{{rterunner.colour}}',
							strokeWeight:4
							});
						polyline_runPath.setMap(map);

						if ('{{rundate}}' == '{{today}}') {
							if (!first_boundary) {
								var first_boundary=runPath[0];
							}
						}

						//Prepare for next fitrunner
						last_i=i;
						runPath.length=0;

					} //if dist_ran > 0;
					
					
				{% endfor %} //for fitdata_list
				
				if(first_boundary == null) {
					first_boundary=route.steps[0].path[0];
				} //If all runners distance = 0
				var last_boundary=stopPath.point; //May break if initial setup all runners are zero
				var bounds=new google.maps.LatLngBounds();
				bounds.extend(first_boundary);
				bounds.extend(last_boundary);
				map.fitBounds(bounds);

			} //if status
		}); //directionsService
	} //displayRoute() function
	
	
function installEpoly() {
 /*********************************************************************\
 *                                                                     *
 * epolys.js                                          by Mike Williams *
 * updated to API v3                                  by Larry Ross    *
 *                                                                     *
 * A Google Maps API Extension                                         *
 *                                                                     *
 * Adds various Methods to google.maps.Polyline *
 * .GetPointAtDistance() returns a GLatLng at the specified distance   *
 *                   along the path.                                   *
 *                   The distance is specified in metres               *
 *                   Reurns null if the path is shorter than that      *
 *                                                                     *
 * .GetPointsAtDistance() returns an array of GLatLngs at the          *
 *                   specified interval along the path.                *
 *                   The distance is specified in metres               *
 ***********************************************************************
 *                                                                     *
 *   This Javascript is provided by Mike Williams                      *
 *   Blackpool Community Church Javascript Team                        *
 *   http://www.blackpoolchurch.org/                                   *
 *   http://econym.org.uk/gmap/                                        *
 *                                                                     *
 *   This work is licenced under a Creative Commons Licence            *
 *   http://creativecommons.org/licenses/by/2.0/uk/                    *
 *                                                                     *
 ***********************************************************************
 *                                                                     *
 * Version 1.1       6-Jun-2007                                        *
 * Version 1.2       1-Jul-2007 - fix: Bounds was omitting vertex zero *
 *                                add: Bearing                         *
 * Version 1.3       28-Nov-2008  add: GetPointsAtDistance()           *
 * Version 1.4       12-Jan-2009  fix: GetPointsAtDistance()           *
 * Version 3.0       11-Aug-2010  update to v3                         *
 *                                                                     *
 \*********************************************************************/

	 // === A method which returns a GLatLng of a point a given distance along the path ===
	 // === Returns null if the path is shorter than the specified distance ===
	 google.maps.Polyline.prototype.GetPointAtDistance = function(metres) {
	   var pathTo = [this.getPath().getAt(0)];
	   var pathFrom = [];
	   // some awkward special cases
	   if (metres == 0) return this.getPath().getAt(0);
	   if (metres < 0) return null;
	   if (this.getPath().getLength() < 2) return null;
	   var dist = 0;
	   var olddist = 0;
	   var i;
console.log('metres:'+metres+' PathLength:'+this.getPath().getLength());

	   for (i = 1;
		 (i < this.getPath().getLength() && dist < metres); i++) {
		 olddist = dist;
		 dist += google.maps.geometry.spherical.computeDistanceBetween(this.getPath().getAt(i), this.getPath().getAt(i - 1));
		 pathTo.push(this.getPath().getAt(i));
	   }
	   if (dist < metres) {
		 return null;
	   }
	   var p1 = this.getPath().getAt(i - 2);
	   var p2 = this.getPath().getAt(i - 1);
	   var m = (metres - olddist) / (dist - olddist);
	   var point = new google.maps.LatLng(p1.lat() + (p2.lat() - p1.lat()) * m, p1.lng() + (p2.lng() - p1.lng()) * m);
	   pathTo.push(point);
	   pathFrom.push(point);
	   for (; i < this.getPath().getLength(); i++) {
		 pathFrom.push(this.getPath().getAt(i));
	   }
	   return {
		 point: point,
		 pathTo: pathTo,
		 pathFrom: pathFrom
	   };
	 } // End of GetPointAtDistance
 } //End of EPoly
			
</script>
{% endblock %}
{% block main_content%}
	<h2>{{route.title}}</h2>
	<div class="row no-gutters">
		<div class="col-md-8">
			<div id="map"></div>	
		</div>
		<div class="col-md-4">
			<div class="row no-gutters">
				<div class="col-md-12 col-6">
					<div id="SideBarChart"></div>
				</div>
				<div class="col-md-12 col-6">
					<div id="PieChart"></div>
				</div>
			</div>
		</div>
	</div> <!-- End of Row -->
				
		<!-- Modal -->
		<div class="modal fade" id="finishedModal" tabindex="-1" role="dialog" aria-labelledby="finishedModalLabel" aria-hidden="true">
		  <div class="modal-dialog" role="document">
			<div class="modal-content">
			  <div class="modal-header">
				<h5 class="modal-title" id="finishedModalLabel">Finished!</h5>
				<button type="button" class="close" data-dismiss="modal" aria-label="Close">
				  <span aria-hidden="true">&times;</span>
				</button>
			  </div>
			  <div class="modal-body">
				<p>Congrtulations, you finished the route!</p>
				<p>You can either close and save the information, so you can take a look at it later or you can simply delete it.<p>
			  </div>
			  <div class="modal-footer">
				<a href="{% url 'finishedroute' finished='save' route=route.pk %}" class="btn btn-primary" role="button">Close and Save</a>
				<a href="{% url 'finishedroute' finished='delete' route=route.pk %}" class="btn btn-danger" role="button">Delete</a>
			  </div>
			</div>
		  </div>
		</div>
		
		
 {% endblock %}
 
 {% block body_script %} 
	<!-- Google Maps -->
	<script src="https://maps.googleapis.com/maps/api/js?key={{API_KEY}}&libraries=geometry&places&callback=initMap" async defer></script>
{% endblock%}	
