var markerArray = [];
var stepDisplay = null;

function initMap() {
 google.maps.event.addDomListener(document.getElementById('btn'), "click", displayRoute);
 installEpoly();
 // Instantiate an info window to hold step text.
 stepDisplay = new google.maps.InfoWindow;
 displayRoute();
}

function displayRoute() {
 var map = new google.maps.Map(document.getElementById('map'));

 var directionsService = new google.maps.DirectionsService();
 var start = {
   lat: 40.750206,
   lng: -73.994563
 };
 var end = {
   lat: 40.714132,
   lng: -74.006292
 };
 var request = {
   origin: start,
   destination: end,
   travelMode: 'WALKING',
   avoidFerries: false,
 }; // Request     

 directionsService.route(request, function(response, status) {
   if (status == 'OK') {
     var route = response.routes[0].legs[0]
     // before
     for (var i = 0; i < route.steps.length; i++) {
       var step = route.steps[i];
       console.log("before step[" + i + "]: start_location=" + step.start_location + " end_location=" + step.end_location + " travel_mode=" + step.travel_mode + " distance=" + JSON.stringify(step.distance) + " duration=" + JSON.stringify(step.duration) + " maneuver=" + step.maneuver + " instructions=" + step.instructions + " path=" + step.path + " encoded_lat_lngs=" + step.encoded_lat_lngs);
     }
     var total_distance = route.distance.value;
     document.getElementById('totalDistance').value = total_distance;
     i = 0
     var dist_ran = document.getElementById('distance').value * 1;
     if (dist_ran > total_distance) {
       console.log("total distance=" + total_distance + " distance ran=" + dist_ran);
       dist_ran = total_distance;
     }
     var sum_dist_steps = 0;

     while (sum_dist_steps < dist_ran) {
       sum_dist_steps += route.steps[i].distance.value;
               console.log("step "+i+" dist="+route.steps[i].distance.value+" sum_dist_steps="+sum_dist_steps);
       i++;
     } // while dist_steps
     i = i - 1;

     if (i > 0) {
       var beforeLatLng = route.steps[i].start_location;
       var afterLatLng = route.steps[i].end_location;
       var fraction = (sum_dist_steps - dist_ran) / route.steps[i].distance.value;
       // var stopLatLng = google.maps.geometry.spherical.interpolate(beforeLatLng, afterLatLng, fraction);
       var stepPoly = new google.maps.Polyline({
         map: map,
         path: route.steps[i].path
       });
       var distanceThisStep = route.steps[i].distance.value;
       var retVal = stepPoly.GetPointAtDistance(distanceThisStep - (sum_dist_steps - dist_ran));
       if (retVal == null) {
         console.log("stepPoly.GetPointAtDistance(" + distanceThisStep + ") returns null");
         return;
       }

       var stopLatLng = retVal.point;
       var insertStep = JSON.parse(JSON.stringify(route.steps[i]));
       console.log("insertStep:" + JSON.stringify(insertStep));
       insertStep.end_location = stopLatLng;
       insertStep.end_point = stopLatLng;
       insertStep.path = retVal.pathFrom;
       // insertStep.encoded_lat_lngs = google.maps.geometry.encoding.encodePath(retVal.pathFrom);
       insertStep.instructions = "New Step<br>" + distanceThisStep + " m after last step"
       route.steps.splice(i + 1, 0, insertStep);
       route.steps[i].end_location = stopLatLng;
       route.steps[i].path = retVal.pathTo;
       // route.steps[i].encoded_lat_lngs = google.maps.geometry.encoding.encodePath(retVal.pathTo);
       route.steps[i + 1].start_location = stopLatLng;
       route.steps[i + 1].start_point = stopLatLng;
       console.log("step[" + i + "]:" + JSON.stringify(route.steps[i]));
       console.log("step[" + (i + 1) + "]:" + JSON.stringify(route.steps[i + 1]));
       console.log(JSON.stringify(route));
     }
     var directionsDisplay = new google.maps.DirectionsRenderer({
       map: map
     });
     for (var i = 0; i < route.steps.length; i++) {
       var step = route.steps[i];
       console.log("after step[" + i + "]: start_location=" + step.start_location + " end_location=" + step.end_location + " travel_mode=" + step.travel_mode + " distance=" + JSON.stringify(step.distance) + " duration=" + JSON.stringify(step.duration) + " maneuver=" + step.maneuver + " instructions=" + step.instructions + " path=" + step.path + " encoded_lat_lngs=" + step.encoded_lat_lngs);
     }
     directionsDisplay.setDirections(response);
     showSteps(response, markerArray, stepDisplay, map);
   } //if status
 }); //directionsService
} //displayRoute() function
function showSteps(directionResult, markerArray, stepDisplay, map) {
 // For each step, place a marker, and add the text to the marker's infowindow.
 // Also attach the marker to an array so we can keep track of it and remove it
 // when calculating new routes.
 var myRoute = directionResult.routes[0].legs[0];
 for (var i = 0; i < myRoute.steps.length; i++) {
   var marker = markerArray[i] = markerArray[i] || new google.maps.Marker;
   // console.log(myRoute.steps[i].start_location.toUrlValue(6));
   marker.setMap(map);
   marker.setPosition(myRoute.steps[i].start_location);
   attachInstructionText(
     stepDisplay, marker, myRoute.steps[i].instructions, map);
 }
}

function attachInstructionText(stepDisplay, marker, text, map) {
 google.maps.event.addListener(marker, 'click', function() {
   // Open an info window when the marker is clicked on, containing the text
   // of the step.
   stepDisplay.setContent(text);
   stepDisplay.open(map, marker);
 });
}

function installEpoly() {
 /*********************************************************************\
 *                                                                     *
 * epolys.js                                          by Mike Williams *
 * updated to API v3                                  by Larry Ross    *
 *                                                                     *
 * A Google Maps API Extension                                         *
 *                                                                     *
 * Adds various Methods to google.maps.Polyline *
 * .GetPointAtDistance() returns a GLatLng at the specified distance   *
 *                   along the path.                                   *
 *                   The distance is specified in metres               *
 *                   Reurns null if the path is shorter than that      *
 *                                                                     *
 * .GetPointsAtDistance() returns an array of GLatLngs at the          *
 *                   specified interval along the path.                *
 *                   The distance is specified in metres               *
 ***********************************************************************
 *                                                                     *
 *   This Javascript is provided by Mike Williams                      *
 *   Blackpool Community Church Javascript Team                        *
 *   http://www.blackpoolchurch.org/                                   *
 *   http://econym.org.uk/gmap/                                        *
 *                                                                     *
 *   This work is licenced under a Creative Commons Licence            *
 *   http://creativecommons.org/licenses/by/2.0/uk/                    *
 *                                                                     *
 ***********************************************************************
 *                                                                     *
 * Version 1.1       6-Jun-2007                                        *
 * Version 1.2       1-Jul-2007 - fix: Bounds was omitting vertex zero *
 *                                add: Bearing                         *
 * Version 1.3       28-Nov-2008  add: GetPointsAtDistance()           *
 * Version 1.4       12-Jan-2009  fix: GetPointsAtDistance()           *
 * Version 3.0       11-Aug-2010  update to v3                         *
 *                                                                     *
 \*********************************************************************/

 // === A method which returns the length of a path in metres ===
 google.maps.Polyline.prototype.Distance = function() {
   var dist = 0;
   for (var i = 1; i < this.getPath().getLength(); i++) {
     dist += google.maps.geometry.spherical.computeDistanceBetween(this.getPath().getAt(i), this.getPath().getAt(i - 1));
   }
   return dist;
 }

 // === A method which returns a GLatLng of a point a given distance along the path ===
 // === Returns null if the path is shorter than the specified distance ===
 google.maps.Polyline.prototype.GetPointAtDistance = function(metres) {
   var pathTo = [this.getPath().getAt(0)];
   var pathFrom = [];
   // some awkward special cases
   if (metres == 0) return this.getPath().getAt(0);
   if (metres < 0) return null;
   if (this.getPath().getLength() < 2) return null;
   var dist = 0;
   var olddist = 0;
   var i;
   for (i = 1;
     (i < this.getPath().getLength() && dist < metres); i++) {
     olddist = dist;
     dist += google.maps.geometry.spherical.computeDistanceBetween(this.getPath().getAt(i), this.getPath().getAt(i - 1));
     pathTo.push(this.getPath().getAt(i));
   }
   if (dist < metres) {
     return null;
   }
   var p1 = this.getPath().getAt(i - 2);
   var p2 = this.getPath().getAt(i - 1);
   var m = (metres - olddist) / (dist - olddist);
   var point = new google.maps.LatLng(p1.lat() + (p2.lat() - p1.lat()) * m, p1.lng() + (p2.lng() - p1.lng()) * m);
   pathTo.push(point);
   pathFrom.push(point);
   for (; i < this.getPath().getLength(); i++) {
     pathFrom.push(this.getPath().getAt(i));
   }
   return {
     point: point,
     pathTo: pathTo,
     pathFrom: pathFrom
   };
 }

 // === A method which returns an array of GLatLngs of points a given interval along the path ===
 google.maps.Polyline.prototype.GetPointsAtDistance = function(metres) {
   var next = metres;
   var points = [];
   // some awkward special cases
   if (metres <= 0) return points;
   var dist = 0;
   var olddist = 0;
   for (var i = 1;
     (i < this.getPath().getLength()); i++) {
     olddist = dist;
     dist += google.maps.geometry.spherical.computeDistanceBetween(this.getPath().getAt(i), this.getPath().getAt(i - 1));
     while (dist > next) {
       var p1 = this.getPath().getAt(i - 1);
       var p2 = this.getPath().getAt(i);
       var m = (next - olddist) / (dist - olddist);
       points.push(new google.maps.LatLng(p1.lat() + (p2.lat() - p1.lat()) * m, p1.lng() + (p2.lng() - p1.lng()) * m));
       next += metres;
     }
   }
   return points;
 }

 // === A method which returns the Vertex number at a given distance along the path ===
 // === Returns null if the path is shorter than the specified distance ===
 google.maps.Polyline.prototype.GetIndexAtDistance = function(metres) {
   // some awkward special cases
   if (metres == 0) return this.getPath().getAt(0);
   if (metres < 0) return null;
   var dist = 0;
   var olddist = 0;
   for (var i = 1;
     (i < this.getPath().getLength() && dist < metres); i++) {
     olddist = dist;
     dist += google.maps.geometry.spherical.computeDistanceBetween(this.getPath().getAt(i), this.getPath().getAt(i - 1));
   }
   if (dist < metres) {
     return null;
   }
   return i;
 }
}